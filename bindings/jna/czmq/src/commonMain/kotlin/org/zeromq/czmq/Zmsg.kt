/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer

class Zmsg {

//    static {
//        Map<String, Boolean> libraries = new LinkedHashMap<>()
//        libraries.put("zmq", false)
//        libraries.put("uuid", true)
//        libraries.put("systemd", true)
//        libraries.put("lz4", true)
//        libraries.put("curl", true)
//        libraries.put("nss", true)
//        libraries.put("microhttpd", true)
//        libraries.put("czmq", false)
//        libraries.put("czmqjni", false)
//        ZmqNativeLoader.loadLibraries(libraries)
//    }

    private interface NativeLib : Library {
        fun zmsg_new(): Pointer
        fun zmsg_recv(source: Pointer): Pointer
        fun zmsg_decode(frame: Pointer): Pointer
        fun zmsg_new_signal(status: Byte): Pointer
        fun destroy(self: Pointer)
        fun zmsg_send(self: Pointer, dest: Pointer): Pointer
        fun zmsg_sendm(self: Pointer, dest: Pointer): Pointer
        fun zmsg_size(self: Pointer): Pointer
        fun zmsg_content_size(self: Pointer): Pointer
        fun zmsg_routing_id(self: Pointer): Int
        fun zmsg_set_routing_id(self: Pointer, routingId: Int): Unit
        fun zmsg_prepend(self: Pointer, frameP: Pointer): Int
        fun zmsg_append(self: Pointer, frameP: Pointer): Int
        fun zmsg_pop(self: Pointer): Pointer
        fun zmsg_pushmem(self: Pointer, data: ByteArray, size: Pointer): Int
        fun zmsg_addmem(self: Pointer, data: ByteArray, size: Pointer): Int
        fun zmsg_pushstr(self: Pointer, string: String): Int
        fun zmsg_addstr(self: Pointer, string: String): Int
        fun zmsg_pushstrf(self: Pointer, format: Array<out String>): Int
        fun zmsg_addstrf(self: Pointer, format: Array<out String>): Int
        fun zmsg_popstr(self: Pointer): String
        fun zmsg_addmsg(self: Pointer, msgP: Pointer): Int
        fun zmsg_popmsg(self: Pointer): Pointer
        fun zmsg_remove(self: Pointer, frame: Pointer): Unit
        fun zmsg_first(self: Pointer): Pointer
        fun zmsg_next(self: Pointer): Pointer
        fun zmsg_last(self: Pointer): Pointer
        fun zmsg_encode(self: Pointer): Pointer
        fun zmsg_dup(self: Pointer): Pointer
        fun zmsg_print(self: Pointer): Unit
        fun zmsg_print_n(self: Pointer, size: Pointer): Unit
        fun zmsg_eq(self: Pointer, other: Pointer): Boolean
        fun zmsg_signal(self: Pointer): Int
        fun zmsg_is(self: Pointer): Boolean
        fun zmsg_test(verbose: Boolean): Unit
    }

    companion object {
        private val nativeLib: NativeLib =
            Native.load("czmq", NativeLib::class.java)

    /**
     * Probe the supplied object, and report if it looks like a zmsg_t.
     */
    fun `is`(self: Pointer): Boolean {
        return nativeLib.zmsg_is(self)
    }

    /**
     * Self test of this class.
     */
    fun test(verbose: Boolean): Unit {
        nativeLib.zmsg_test(verbose)
    }

    }

    var self: Pointer

    /**
     * Create a new empty message object
     */
    constructor() {
        /*  TODO: if __new fails, self is null...            */
        self = nativeLib.zmsg_new()
    }

    constructor(pointer: Pointer) {
        self = pointer
    }

    /**
     * Receive message from socket, returns zmsg_t object or NULL if the recv
     * was interrupted. Does a blocking recv. If you want to not block then use
     * the zloop class or zmsg_recv_nowait or zmq_poll to check for socket input
     * before receiving.
     */
//    public static Zmsg recv (source: Pointer) {
//        return new Zmsg (nativeLib.zmsg_recv (source))
//    }
//
    /**
     * Decodes a serialized message frame created by zmsg_encode () and returns
     * a new zmsg_t object. Returns NULL if the frame was badly formatted or
     * there was insufficient memory to work.
     */
//    public static Zmsg decode (frame: Zframe) {
//        return new Zmsg (nativeLib.zmsg_decode (frame.self))
//    }
//
    /**
     * Generate a signal message encoding the given status. A signal is a short
     * message carrying a 1-byte success/failure code (by convention, 0 means
     * OK). Signals are encoded to be distinguishable from "normal" messages.
     */
//    public static Zmsg newSignal (status: Byte) {
//        return new Zmsg (nativeLib.zmsg_new_signal (status))
//    }
//
    /**
     * Destroy a message object and all frames it contains
     */
//    @Override
//    public void close () {
//        nativeLib.zmsg_destroy(self)
//        self = 0
//    }
//
    /**
     * Send message to destination socket, and destroy the message after sending
     * it successfully. If the message has no frames, sends nothing but destroys
     * the message anyhow. Nullifies the caller's reference to the message (as
     * it is a destructor).
     */
    fun send(dest: Pointer): Unit {
        self = nativeLib.zmsg_send(self, dest)
    }

    /**
     * Send message to destination socket as part of a multipart sequence, and
     * destroy the message after sending it successfully. Note that after a
     * zmsg_sendm, you must call zmsg_send or another method that sends a final
     * message part. If the message has no frames, sends nothing but destroys
     * the message anyhow. Nullifies the caller's reference to the message (as
     * it is a destructor).
     */
    fun sendm(dest: Pointer): Unit {
        self = nativeLib.zmsg_sendm(self, dest)
    }

    /**
     * Return size of message, i.e. number of frames (0 or more).
     */
    fun size(): Pointer {
        return nativeLib.zmsg_size(self)
    }

    /**
     * Return total size of all frames in message.
     */
    fun contentSize(): Pointer {
        return nativeLib.zmsg_content_size(self)
    }

    /**
     * Return message routing ID, if the message came from a ZMQ_SERVER socket.
     * Else returns zero.
     */
    fun routingId(): Int {
        return nativeLib.zmsg_routing_id(self)
    }

    /**
     * Set routing ID on message. This is used if/when the message is sent to a
     * ZMQ_SERVER socket.
     */
    fun setRoutingId(routingId: Int): Unit {
        nativeLib.zmsg_set_routing_id(self, routingId)
    }

    /**
     * Push frame to the front of the message, i.e. before all other frames.
     * Message takes ownership of frame, will destroy it when message is sent.
     * Returns 0 on success, -1 on error. Deprecates zmsg_push, which did not
     * nullify the caller's frame reference.
     */
    fun prepend(frameP: Zframe): Int {
        return nativeLib.zmsg_prepend(self, frameP.self)
    }

    /**
     * Add frame to the end of the message, i.e. after all other frames.
     * Message takes ownership of frame, will destroy it when message is sent.
     * Returns 0 on success. Deprecates zmsg_add, which did not nullify the
     * caller's frame reference.
     */
    fun append(frameP: Zframe): Int {
        return nativeLib.zmsg_append(self, frameP.self)
    }

    /**
     * Remove first frame from message, if any. Returns frame, or NULL.
     */
    fun pop(): Zframe {
        return Zframe (nativeLib.zmsg_pop(self))
    }

    /**
     * Push block of memory to front of message, as a new frame.
     * Returns 0 on success, -1 on error.
     */
    fun pushmem(data: ByteArray, size: Pointer): Int {
        return nativeLib.zmsg_pushmem(self, data, size)
    }

    /**
     * Add block of memory to the end of the message, as a new frame.
     * Returns 0 on success, -1 on error.
     */
    fun addmem(data: ByteArray, size: Pointer): Int {
        return nativeLib.zmsg_addmem(self, data, size)
    }

    /**
     * Push string as new frame to front of message.
     * Returns 0 on success, -1 on error.
     */
    fun pushstr(string: String): Int {
        return nativeLib.zmsg_pushstr(self, string)
    }

    /**
     * Push string as new frame to end of message.
     * Returns 0 on success, -1 on error.
     */
    fun addstr(string: String): Int {
        return nativeLib.zmsg_addstr(self, string)
    }

    /**
     * Push formatted string as new frame to front of message.
     * Returns 0 on success, -1 on error.
     */
    fun pushstrf(vararg format: String): Int {
        return nativeLib.zmsg_pushstrf(self, format)
    }

    /**
     * Push formatted string as new frame to end of message.
     * Returns 0 on success, -1 on error.
     */
    fun addstrf(vararg format: String): Int {
        return nativeLib.zmsg_addstrf(self, format)
    }

    /**
     * Pop frame off front of message, return as fresh string. If there were
     * no more frames in the message, returns NULL.
     */
    fun popstr(): String {
        return nativeLib.zmsg_popstr(self)
    }

    /**
     * Push encoded message as a new frame. Message takes ownership of
     * submessage, so the original is destroyed in this call. Returns 0 on
     * success, -1 on error.
     */
    fun addmsg(msgP: Zmsg): Int {
        return nativeLib.zmsg_addmsg(self, msgP.self)
    }

    /**
     * Remove first submessage from message, if any. Returns zmsg_t, or NULL if
     * decoding was not successful.
     */
    fun popmsg(): Zmsg {
        return Zmsg (nativeLib.zmsg_popmsg(self))
    }

    /**
     * Remove specified frame from list, if present. Does not destroy frame.
     */
    fun remove(frame: Zframe): Unit {
        nativeLib.zmsg_remove(self, frame.self)
    }

    /**
     * Set cursor to first frame in message. Returns frame, or NULL, if the
     * message is empty. Use this to navigate the frames as a list.
     */
    fun first(): Zframe {
        return Zframe (nativeLib.zmsg_first(self))
    }

    /**
     * Return the next frame. If there are no more frames, returns NULL. To move
     * to the first frame call zmsg_first(). Advances the cursor.
     */
    fun next(): Zframe {
        return Zframe (nativeLib.zmsg_next(self))
    }

    /**
     * Return the last frame. If there are no frames, returns NULL.
     */
    fun last(): Zframe {
        return Zframe (nativeLib.zmsg_last(self))
    }

    /**
     * Serialize multipart message to a single message frame. Use this method
     * to send structured messages across transports that do not support
     * multipart data. Allocates and returns a new frame containing the
     * serialized message. To decode a serialized message frame, use
     * zmsg_decode ().
     */
    fun encode(): Zframe {
        return Zframe (nativeLib.zmsg_encode(self))
    }

    /**
     * Create copy of message, as new message object. Returns a fresh zmsg_t
     * object. If message is null, or memory was exhausted, returns null.
     */
    fun dup(): Zmsg {
        return Zmsg (nativeLib.zmsg_dup(self))
    }

    /**
     * Send message to zsys log sink (may be stdout, or system facility as
     * configured by zsys_set_logstream).
     * Long messages are truncated.
     */
    fun print(): Unit {
        nativeLib.zmsg_print(self)
    }

    /**
     * Send message to zsys log sink (may be stdout, or system facility as
     * configured by zsys_set_logstream).
     * Message length is specified; no truncation unless length is zero.
     * Backwards compatible with zframe_print when length is zero.
     */
    fun printN(size: Pointer): Unit {
        nativeLib.zmsg_print_n(self, size)
    }

    /**
     * Return true if the two messages have the same number of frames and each
     * frame in the first message is identical to the corresponding frame in the
     * other message. As with zframe_eq, return false if either message is NULL.
     */
    fun eq(other: Zmsg): Boolean {
        return nativeLib.zmsg_eq(self, other.self)
    }

    /**
     * Return signal value, 0 or greater, if message is a signal, -1 if not.
     */
    fun signal(): Int {
        return nativeLib.zmsg_signal(self)
    }

}
