/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer

class Zsys {

//    static {
//        Map<String, Boolean> libraries = new LinkedHashMap<>()
//        libraries.put("zmq", false)
//        libraries.put("uuid", true)
//        libraries.put("systemd", true)
//        libraries.put("lz4", true)
//        libraries.put("curl", true)
//        libraries.put("nss", true)
//        libraries.put("microhttpd", true)
//        libraries.put("czmq", false)
//        libraries.put("czmqjni", false)
//        ZmqNativeLoader.loadLibraries(libraries)
//    }

    private interface NativeLib : Library {
        fun zsys_init(): Pointer
        fun zsys_shutdown(): Unit
        fun zsys_socket(type: Int, filename: String, lineNbr: Pointer): Pointer
        fun zsys_close(handle: Pointer, filename: String, lineNbr: Pointer): Int
        fun zsys_sockname(socktype: Int): String
        fun zsys_create_pipe(backendP: Pointer): Pointer
        fun zsys_handler_reset(): Unit
        fun zsys_catch_interrupts(): Unit
        fun zsys_is_interrupted(): Boolean
        fun zsys_set_interrupted(): Unit
        fun zsys_file_exists(filename: String): Boolean
        fun zsys_file_modified(filename: String): Pointer
        fun zsys_file_mode(filename: String): Int
        fun zsys_file_delete(filename: String): Int
        fun zsys_file_stable(filename: String): Boolean
        fun zsys_dir_create(pathname: Array<out String>): Int
        fun zsys_dir_delete(pathname: Array<out String>): Int
        fun zsys_dir_change(pathname: String): Int
        fun zsys_file_mode_private(): Unit
        fun zsys_file_mode_default(): Unit
        fun zsys_version(major: Int, minor: Int, patch: Int): Unit
        fun zsys_sprintf_hint(hint: Int, format: Array<out String>): String
        fun zsys_sprintf(format: Array<out String>): String
        fun zsys_socket_error(reason: String): Unit
        fun zsys_hostname(): String
        fun zsys_daemonize(workdir: String): Int
        fun zsys_run_as(lockfile: String, group: String, user: String): Int
        fun zsys_has_curve(): Boolean
        fun zsys_set_io_threads(ioThreads: Pointer): Unit
        fun zsys_set_thread_sched_policy(policy: Int): Unit
        fun zsys_set_thread_priority(priority: Int): Unit
        fun zsys_set_thread_name_prefix(prefix: Int): Unit
        fun zsys_thread_name_prefix(): Int
        fun zsys_set_thread_name_prefix_str(prefix: String): Unit
        fun zsys_thread_name_prefix_str(): String
        fun zsys_thread_affinity_cpu_add(cpu: Int): Unit
        fun zsys_thread_affinity_cpu_remove(cpu: Int): Unit
        fun zsys_set_max_sockets(maxSockets: Pointer): Unit
        fun zsys_socket_limit(): Pointer
        fun zsys_set_max_msgsz(maxMsgsz: Int): Unit
        fun zsys_max_msgsz(): Int
        fun zsys_set_zero_copy_recv(zeroCopy: Int): Unit
        fun zsys_zero_copy_recv(): Int
        fun zsys_set_file_stable_age_msec(fileStableAgeMsec: Pointer): Unit
        fun zsys_file_stable_age_msec(): Pointer
        fun zsys_set_linger(linger: Pointer): Unit
        fun zsys_set_sndhwm(sndhwm: Pointer): Unit
        fun zsys_set_rcvhwm(rcvhwm: Pointer): Unit
        fun zsys_set_pipehwm(pipehwm: Pointer): Unit
        fun zsys_pipehwm(): Pointer
        fun zsys_set_ipv6(ipv6: Int): Unit
        fun zsys_ipv6(): Int
        fun zsys_ipv6_available(): Boolean
        fun zsys_set_interface(value: String): Unit
        fun zsys_interface(): String
        fun zsys_set_ipv6_address(value: String): Unit
        fun zsys_ipv6_address(): String
        fun zsys_set_ipv6_mcast_address(value: String): Unit
        fun zsys_ipv6_mcast_address(): String
        fun zsys_set_ipv4_mcast_address(value: String): Unit
        fun zsys_ipv4_mcast_address(): String
        fun zsys_set_mcast_ttl(value: Byte): Unit
        fun zsys_mcast_ttl(): Byte
        fun zsys_set_auto_use_fd(autoUseFd: Int): Unit
        fun zsys_auto_use_fd(): Int
        fun zsys_zprintf(format: String, args: Pointer): String
        fun zsys_zprintf_error(format: String, args: Pointer): String
        fun zsys_zplprintf(format: String, args: Pointer): String
        fun zsys_zplprintf_error(format: String, args: Pointer): String
        fun zsys_set_logident(value: String): Unit
        fun zsys_set_logsender(endpoint: String): Unit
        fun zsys_set_logsystem(logsystem: Boolean): Unit
        fun zsys_error(format: Array<out String>): Unit
        fun zsys_warning(format: Array<out String>): Unit
        fun zsys_notice(format: Array<out String>): Unit
        fun zsys_info(format: Array<out String>): Unit
        fun zsys_debug(format: Array<out String>): Unit
        fun zsys_test(verbose: Boolean): Unit
    }

    companion object {
        private val nativeLib: NativeLib =
            Native.load("czmq", NativeLib::class.java)

    /**
     * Initialize CZMQ zsys layer; this happens automatically when you create
     * a socket or an actor; however this call lets you force initialization
     * earlier, so e.g. logging is properly set-up before you start working.
     * Not threadsafe, so call only from main thread. Safe to call multiple
     * times. Returns global CZMQ context.
     */
    fun init(): Pointer {
        return nativeLib.zsys_init()
    }

    /**
     * Optionally shut down the CZMQ zsys layer; this normally happens automatically
     * when the process exits; however this call lets you force a shutdown
     * earlier, avoiding any potential problems with atexit() ordering, especially
     * with Windows dlls.
     */
    fun shutdown(): Unit {
        nativeLib.zsys_shutdown()
    }

    /**
     * Get a new ZMQ socket, automagically creating a ZMQ context if this is
     * the first time. Caller is responsible for destroying the ZMQ socket
     * before process exits, to avoid a ZMQ deadlock. Note: you should not use
     * this method in CZMQ apps, use zsock_new() instead.
     * *** This is for CZMQ internal use only and may change arbitrarily ***
     */
    fun socket(type: Int, filename: String, lineNbr: Pointer): Pointer {
        return nativeLib.zsys_socket(type, filename, lineNbr)
    }

    /**
     * Destroy/close a ZMQ socket. You should call this for every socket you
     * create using zsys_socket().
     * *** This is for CZMQ internal use only and may change arbitrarily ***
     */
    fun `close`(handle: Pointer, filename: String, lineNbr: Pointer): Int {
        return nativeLib.zsys_close(handle, filename, lineNbr)
    }

    /**
     * Return ZMQ socket name for socket type
     * *** This is for CZMQ internal use only and may change arbitrarily ***
     */
    fun sockname(socktype: Int): String {
        return nativeLib.zsys_sockname(socktype)
    }

    /**
     * Create a pipe, which consists of two PAIR sockets connected over inproc.
     * The pipe is configured to use the zsys_pipehwm setting. Returns the
     * frontend socket successful, NULL if failed.
     */
    fun createPipe(backendP: Zsock): Zsock {
        return Zsock (nativeLib.zsys_create_pipe(backendP.self))
    }

    /**
     * Reset interrupt handler, call this at exit if needed
     */
    fun handlerReset(): Unit {
        nativeLib.zsys_handler_reset()
    }

    /**
     * Set default interrupt handler, so Ctrl-C or SIGTERM will set
     * zsys_interrupted. Idempotent; safe to call multiple times.
     * Can be suppressed by ZSYS_SIGHANDLER=false
     * *** This is for CZMQ internal use only and may change arbitrarily ***
     */
    fun catchInterrupts(): Unit {
        nativeLib.zsys_catch_interrupts()
    }

    /**
     * Check if default interrupt handler of Ctrl-C or SIGTERM was called.
     * Does not work if ZSYS_SIGHANDLER is false and code does not call
     * set interrupted on signal.
     */
    fun isInterrupted(): Boolean {
        return nativeLib.zsys_is_interrupted()
    }

    /**
     * Set interrupted flag. This is done by default signal handler, however
     * this can be handy for language bindings or cases without default
     * signal handler.
     */
    fun setInterrupted(): Unit {
        nativeLib.zsys_set_interrupted()
    }

    /**
     * Return 1 if file exists, else zero
     */
    fun fileExists(filename: String): Boolean {
        return nativeLib.zsys_file_exists(filename)
    }

    /**
     * Return file modification time. Returns 0 if the file does not exist.
     */
    fun fileModified(filename: String): Pointer {
        return nativeLib.zsys_file_modified(filename)
    }

    /**
     * Return file mode; provides at least support for the POSIX S_ISREG(m)
     * and S_ISDIR(m) macros and the S_IRUSR and S_IWUSR bits, on all boxes.
     * Returns a mode_t cast to int, or -1 in case of error.
     */
    fun fileMode(filename: String): Int {
        return nativeLib.zsys_file_mode(filename)
    }

    /**
     * Delete file. Does not complain if the file is absent
     */
    fun fileDelete(filename: String): Int {
        return nativeLib.zsys_file_delete(filename)
    }

    /**
     * Check if file is 'stable'
     */
    fun fileStable(filename: String): Boolean {
        return nativeLib.zsys_file_stable(filename)
    }

    /**
     * Create a file path if it doesn't exist. The file path is treated as
     * printf format.
     */
    fun dirCreate(vararg pathname: String): Int {
        return nativeLib.zsys_dir_create(pathname)
    }

    /**
     * Remove a file path if empty; the pathname is treated as printf format.
     */
    fun dirDelete(vararg pathname: String): Int {
        return nativeLib.zsys_dir_delete(pathname)
    }

    /**
     * Move to a specified working directory. Returns 0 if OK, -1 if this failed.
     */
    fun dirChange(pathname: String): Int {
        return nativeLib.zsys_dir_change(pathname)
    }

    /**
     * Set private file creation mode; all files created from here will be
     * readable/writable by the owner only.
     */
    fun fileModePrivate(): Unit {
        nativeLib.zsys_file_mode_private()
    }

    /**
     * Reset default file creation mode; all files created from here will use
     * process file mode defaults.
     */
    fun fileModeDefault(): Unit {
        nativeLib.zsys_file_mode_default()
    }

    /**
     * Return the CZMQ version for run-time API detection; returns version
     * number into provided fields, providing reference isn't null in each case.
     */
    fun version(major: Int, minor: Int, patch: Int): Unit {
        nativeLib.zsys_version(major, minor, patch)
    }

    /**
     * Format a string using printf formatting, returning a freshly allocated
     * buffer. If there was insufficient memory, returns NULL. Free the returned
     * string using zstr_free(). The hinted version allows one to optimize by using
     * a larger starting buffer size (known to/assumed by the developer) and so
     * avoid reallocations.
     */
    fun sprintfHint(hint: Int, vararg format: String): String {
        return nativeLib.zsys_sprintf_hint(hint, format)
    }

    /**
     * Format a string using printf formatting, returning a freshly allocated
     * buffer. If there was insufficient memory, returns NULL. Free the returned
     * string using zstr_free().
     */
    fun sprintf(vararg format: String): String {
        return nativeLib.zsys_sprintf(format)
    }

    /**
     * Handle an I/O error on some socket operation; will report and die on
     * fatal errors, and continue silently on "try again" errors.
     * *** This is for CZMQ internal use only and may change arbitrarily ***
     */
    fun socketError(reason: String): Unit {
        nativeLib.zsys_socket_error(reason)
    }

    /**
     * Return current host name, for use in public tcp:// endpoints. Caller gets
     * a freshly allocated string, should free it using zstr_free(). If the host
     * name is not resolvable, returns NULL.
     */
    fun hostname(): String {
        return nativeLib.zsys_hostname()
    }

    /**
     * Move the current process into the background. The precise effect depends
     * on the operating system. On POSIX boxes, moves to a specified working
     * directory (if specified), closes all file handles, reopens stdin, stdout,
     * and stderr to the null device, and sets the process to ignore SIGHUP. On
     * Windows, does nothing. Returns 0 if OK, -1 if there was an error.
     */
    fun daemonize(workdir: String): Int {
        return nativeLib.zsys_daemonize(workdir)
    }

    /**
     * Drop the process ID into the lockfile, with exclusive lock, and switch
     * the process to the specified group and/or user. Any of the arguments
     * may be null, indicating a no-op. Returns 0 on success, -1 on failure.
     * Note if you combine this with zsys_daemonize, run after, not before
     * that method, or the lockfile will hold the wrong process ID.
     */
    fun runAs(lockfile: String, group: String, user: String): Int {
        return nativeLib.zsys_run_as(lockfile, group, user)
    }

    /**
     * Returns true if the underlying libzmq supports CURVE security.
     * Uses a heuristic probe according to the version of libzmq being used.
     */
    fun hasCurve(): Boolean {
        return nativeLib.zsys_has_curve()
    }

    /**
     * Configure the number of I/O threads that ZeroMQ will use. A good
     * rule of thumb is one thread per gigabit of traffic in or out. The
     * default is 1, sufficient for most applications. If the environment
     * variable ZSYS_IO_THREADS is defined, that provides the default.
     * Note that this method is valid only before any socket is created.
     */
    fun setIoThreads(ioThreads: Pointer): Unit {
        nativeLib.zsys_set_io_threads(ioThreads)
    }

    /**
     * Configure the scheduling policy of the ZMQ context thread pool.
     * Not available on Windows. See the sched_setscheduler man page or sched.h
     * for more information. If the environment variable ZSYS_THREAD_SCHED_POLICY
     * is defined, that provides the default.
     * Note that this method is valid only before any socket is created.
     */
    fun setThreadSchedPolicy(policy: Int): Unit {
        nativeLib.zsys_set_thread_sched_policy(policy)
    }

    /**
     * Configure the scheduling priority of the ZMQ context thread pool.
     * Not available on Windows. See the sched_setscheduler man page or sched.h
     * for more information. If the environment variable ZSYS_THREAD_PRIORITY is
     * defined, that provides the default.
     * Note that this method is valid only before any socket is created.
     */
    fun setThreadPriority(priority: Int): Unit {
        nativeLib.zsys_set_thread_priority(priority)
    }

    /**
     * Configure the numeric prefix to each thread created for the internal
     * context's thread pool. This option is only supported on Linux.
     * If the environment variable ZSYS_THREAD_NAME_PREFIX is defined, that
     * provides the default.
     * Note that this method is valid only before any socket is created.
     */
    fun setThreadNamePrefix(prefix: Int): Unit {
        nativeLib.zsys_set_thread_name_prefix(prefix)
    }

    /**
     * Return thread name prefix.
     */
    fun threadNamePrefix(): Int {
        return nativeLib.zsys_thread_name_prefix()
    }

    /**
     * Configure the numeric prefix to each thread created for the internal
     * context's thread pool. This option is only supported on Linux.
     * If the environment variable ZSYS_THREAD_NAME_PREFIX_STR is defined, that
     * provides the default.
     * Note that this method is valid only before any socket is created.
     */
    fun setThreadNamePrefixStr(prefix: String): Unit {
        nativeLib.zsys_set_thread_name_prefix_str(prefix)
    }

    /**
     * Return thread name prefix.
     */
    fun threadNamePrefixStr(): String {
        return nativeLib.zsys_thread_name_prefix_str()
    }

    /**
     * Adds a specific CPU to the affinity list of the ZMQ context thread pool.
     * This option is only supported on Linux.
     * Note that this method is valid only before any socket is created.
     */
    fun threadAffinityCpuAdd(cpu: Int): Unit {
        nativeLib.zsys_thread_affinity_cpu_add(cpu)
    }

    /**
     * Removes a specific CPU to the affinity list of the ZMQ context thread pool.
     * This option is only supported on Linux.
     * Note that this method is valid only before any socket is created.
     */
    fun threadAffinityCpuRemove(cpu: Int): Unit {
        nativeLib.zsys_thread_affinity_cpu_remove(cpu)
    }

    /**
     * Configure the number of sockets that ZeroMQ will allow. The default
     * is 1024. The actual limit depends on the system, and you can query it
     * by using zsys_socket_limit (). A value of zero means "maximum".
     * Note that this method is valid only before any socket is created.
     */
    fun setMaxSockets(maxSockets: Pointer): Unit {
        nativeLib.zsys_set_max_sockets(maxSockets)
    }

    /**
     * Return maximum number of ZeroMQ sockets that the system will support.
     */
    fun socketLimit(): Pointer {
        return nativeLib.zsys_socket_limit()
    }

    /**
     * Configure the maximum allowed size of a message sent.
     * The default is INT_MAX.
     */
    fun setMaxMsgsz(maxMsgsz: Int): Unit {
        nativeLib.zsys_set_max_msgsz(maxMsgsz)
    }

    /**
     * Return maximum message size.
     */
    fun maxMsgsz(): Int {
        return nativeLib.zsys_max_msgsz()
    }

    /**
     * Configure whether to use zero copy strategy in libzmq. If the environment
     * variable ZSYS_ZERO_COPY_RECV is defined, that provides the default.
     * Otherwise the default is 1.
     */
    fun setZeroCopyRecv(zeroCopy: Int): Unit {
        nativeLib.zsys_set_zero_copy_recv(zeroCopy)
    }

    /**
     * Return ZMQ_ZERO_COPY_RECV option.
     */
    fun zeroCopyRecv(): Int {
        return nativeLib.zsys_zero_copy_recv()
    }

    /**
     * Configure the threshold value of filesystem object age per st_mtime
     * that should elapse until we consider that object "stable" at the
     * current zclock_time() moment.
     * The default is S_DEFAULT_ZSYS_FILE_STABLE_AGE_MSEC defined in zsys.c
     * which generally depends on host OS, with fallback value of 5000.
     */
    fun setFileStableAgeMsec(fileStableAgeMsec: Pointer): Unit {
        nativeLib.zsys_set_file_stable_age_msec(fileStableAgeMsec)
    }

    /**
     * Return current threshold value of file stable age in msec.
     * This can be used in code that chooses to wait for this timeout
     * before testing if a filesystem object is "stable" or not.
     */
    fun fileStableAgeMsec(): Pointer {
        return nativeLib.zsys_file_stable_age_msec()
    }

    /**
     * Configure the default linger timeout in msecs for new zsock instances.
     * You can also set this separately on each zsock_t instance. The default
     * linger time is zero, i.e. any pending messages will be dropped. If the
     * environment variable ZSYS_LINGER is defined, that provides the default.
     * Note that process exit will typically be delayed by the linger time.
     */
    fun setLinger(linger: Pointer): Unit {
        nativeLib.zsys_set_linger(linger)
    }

    /**
     * Configure the default outgoing pipe limit (HWM) for new zsock instances.
     * You can also set this separately on each zsock_t instance. The default
     * HWM is 1,000, on all versions of ZeroMQ. If the environment variable
     * ZSYS_SNDHWM is defined, that provides the default. Note that a value of
     * zero means no limit, i.e. infinite memory consumption.
     */
    fun setSndhwm(sndhwm: Pointer): Unit {
        nativeLib.zsys_set_sndhwm(sndhwm)
    }

    /**
     * Configure the default incoming pipe limit (HWM) for new zsock instances.
     * You can also set this separately on each zsock_t instance. The default
     * HWM is 1,000, on all versions of ZeroMQ. If the environment variable
     * ZSYS_RCVHWM is defined, that provides the default. Note that a value of
     * zero means no limit, i.e. infinite memory consumption.
     */
    fun setRcvhwm(rcvhwm: Pointer): Unit {
        nativeLib.zsys_set_rcvhwm(rcvhwm)
    }

    /**
     * Configure the default HWM for zactor internal pipes; this is set on both
     * ends of the pipe, for outgoing messages only (sndhwm). The default HWM is
     * 1,000, on all versions of ZeroMQ. If the environment var ZSYS_ACTORHWM is
     * defined, that provides the default. Note that a value of zero means no
     * limit, i.e. infinite memory consumption.
     */
    fun setPipehwm(pipehwm: Pointer): Unit {
        nativeLib.zsys_set_pipehwm(pipehwm)
    }

    /**
     * Return the HWM for zactor internal pipes.
     */
    fun pipehwm(): Pointer {
        return nativeLib.zsys_pipehwm()
    }

    /**
     * Configure use of IPv6 for new zsock instances. By default sockets accept
     * and make only IPv4 connections. When you enable IPv6, sockets will accept
     * and connect to both IPv4 and IPv6 peers. You can override the setting on
     * each zsock_t instance. The default is IPv4 only (ipv6 set to 0). If the
     * environment variable ZSYS_IPV6 is defined (as 1 or 0), this provides the
     * default. Note: has no effect on ZMQ v2.
     */
    fun setIpv6(ipv6: Int): Unit {
        nativeLib.zsys_set_ipv6(ipv6)
    }

    /**
     * Return use of IPv6 for zsock instances.
     */
    fun ipv6(): Int {
        return nativeLib.zsys_ipv6()
    }

    /**
     * Test if ipv6 is available on the system. Return true if available.
     * The only way to reliably check is to actually open a socket and
     * try to bind it. (ported from libzmq)
     */
    fun ipv6Available(): Boolean {
        return nativeLib.zsys_ipv6_available()
    }

    /**
     * Set network interface name to use for broadcasts, particularly zbeacon.
     * This lets the interface be configured for test environments where required.
     * For example, on Mac OS X, zbeacon cannot bind to 255.255.255.255 which is
     * the default when there is no specified interface. If the environment
     * variable ZSYS_INTERFACE is set, use that as the default interface name.
     * Setting the interface to "*" means "use all available interfaces".
     */
    fun setInterface(value: String): Unit {
        nativeLib.zsys_set_interface(value)
    }

    /**
     * Return network interface to use for broadcasts, or "" if none was set.
     */
    fun `interface`(): String {
        return nativeLib.zsys_interface()
    }

    /**
     * Set IPv6 address to use zbeacon socket, particularly for receiving zbeacon.
     * This needs to be set IPv6 is enabled as IPv6 can have multiple addresses
     * on a given interface. If the environment variable ZSYS_IPV6_ADDRESS is set,
     * use that as the default IPv6 address.
     */
    fun setIpv6Address(value: String): Unit {
        nativeLib.zsys_set_ipv6_address(value)
    }

    /**
     * Return IPv6 address to use for zbeacon reception, or "" if none was set.
     */
    fun ipv6Address(): String {
        return nativeLib.zsys_ipv6_address()
    }

    /**
     * Set IPv6 milticast address to use for sending zbeacon messages. This needs
     * to be set if IPv6 is enabled. If the environment variable
     * ZSYS_IPV6_MCAST_ADDRESS is set, use that as the default IPv6 multicast
     * address.
     */
    fun setIpv6McastAddress(value: String): Unit {
        nativeLib.zsys_set_ipv6_mcast_address(value)
    }

    /**
     * Return IPv6 multicast address to use for sending zbeacon, or "" if none was
     * set.
     */
    fun ipv6McastAddress(): String {
        return nativeLib.zsys_ipv6_mcast_address()
    }

    /**
     * Set IPv4 multicast address to use for sending zbeacon messages. By default
     * IPv4 multicast is NOT used. If the environment variable
     * ZSYS_IPV4_MCAST_ADDRESS is set, use that as the default IPv4 multicast
     * address. Calling this function or setting ZSYS_IPV4_MCAST_ADDRESS
     * will enable IPv4 zbeacon messages.
     */
    fun setIpv4McastAddress(value: String): Unit {
        nativeLib.zsys_set_ipv4_mcast_address(value)
    }

    /**
     * Return IPv4 multicast address to use for sending zbeacon, or NULL if none was
     * set.
     */
    fun ipv4McastAddress(): String {
        return nativeLib.zsys_ipv4_mcast_address()
    }

    /**
     * Set multicast TTL default is 1
     */
    fun setMcastTtl(value: Byte): Unit {
        nativeLib.zsys_set_mcast_ttl(value)
    }

    /**
     * Get multicast TTL
     */
    fun mcastTtl(): Byte {
        return nativeLib.zsys_mcast_ttl()
    }

    /**
     * Configure the automatic use of pre-allocated FDs when creating new sockets.
     * If 0 (default), nothing will happen. Else, when a new socket is bound, the
     * system API will be used to check if an existing pre-allocated FD with a
     * matching port (if TCP) or path (if IPC) exists, and if it does it will be
     * set via the ZMQ_USE_FD socket option so that the library will use it
     * instead of creating a new socket.
     */
    fun setAutoUseFd(autoUseFd: Int): Unit {
        nativeLib.zsys_set_auto_use_fd(autoUseFd)
    }

    /**
     * Return use of automatic pre-allocated FDs for zsock instances.
     */
    fun autoUseFd(): Int {
        return nativeLib.zsys_auto_use_fd()
    }

    /**
     * Print formatted string. Format is specified by variable names
     * in Python-like format style
     *
     * "%(KEY)s=%(VALUE)s", KEY=key, VALUE=value
     * become
     * "key=value"
     *
     * Returns freshly allocated string or NULL in a case of error.
     * Not enough memory, invalid format specifier, name not in args
     */
    fun zprintf(format: String, args: Zhash): String {
        return nativeLib.zsys_zprintf(format, args.self)
    }

    /**
     * Return error string for given format/args combination.
     */
    fun zprintfError(format: String, args: Zhash): String {
        return nativeLib.zsys_zprintf_error(format, args.self)
    }

    /**
     * Print formatted string. Format is specified by variable names
     * in Python-like format style
     *
     * "%(KEY)s=%(VALUE)s", KEY=key, VALUE=value
     * become
     * "key=value"
     *
     * Returns freshly allocated string or NULL in a case of error.
     * Not enough memory, invalid format specifier, name not in args
     */
    fun zplprintf(format: String, args: Zconfig): String {
        return nativeLib.zsys_zplprintf(format, args.self)
    }

    /**
     * Return error string for given format/args combination.
     */
    fun zplprintfError(format: String, args: Zconfig): String {
        return nativeLib.zsys_zplprintf_error(format, args.self)
    }

    /**
     * Set log identity, which is a string that prefixes all log messages sent
     * by this process. The log identity defaults to the environment variable
     * ZSYS_LOGIDENT, if that is set.
     */
    fun setLogident(value: String): Unit {
        nativeLib.zsys_set_logident(value)
    }

    /**
     * Sends log output to a PUB socket bound to the specified endpoint. To
     * collect such log output, create a SUB socket, subscribe to the traffic
     * you care about, and connect to the endpoint. Log traffic is sent as a
     * single string frame, in the same format as when sent to stdout. The
     * log system supports a single sender; multiple calls to this method will
     * bind the same sender to multiple endpoints. To disable the sender, call
     * this method with a null argument.
     */
    fun setLogsender(endpoint: String): Unit {
        nativeLib.zsys_set_logsender(endpoint)
    }

    /**
     * Enable or disable logging to the system facility (syslog on POSIX boxes,
     * event log on Windows). By default this is disabled.
     */
    fun setLogsystem(logsystem: Boolean): Unit {
        nativeLib.zsys_set_logsystem(logsystem)
    }

    /**
     * Log error condition - highest priority
     */
    fun error(vararg format: String): Unit {
        nativeLib.zsys_error(format)
    }

    /**
     * Log warning condition - high priority
     */
    fun warning(vararg format: String): Unit {
        nativeLib.zsys_warning(format)
    }

    /**
     * Log normal, but significant, condition - normal priority
     */
    fun notice(vararg format: String): Unit {
        nativeLib.zsys_notice(format)
    }

    /**
     * Log informational message - low priority
     */
    fun info(vararg format: String): Unit {
        nativeLib.zsys_info(format)
    }

    /**
     * Log debug-level message - lowest priority
     */
    fun debug(vararg format: String): Unit {
        nativeLib.zsys_debug(format)
    }

    /**
     * Self test of this class.
     */
    fun test(verbose: Boolean): Unit {
        nativeLib.zsys_test(verbose)
    }

    }
}
