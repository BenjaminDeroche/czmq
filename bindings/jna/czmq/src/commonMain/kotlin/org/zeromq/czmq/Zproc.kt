/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer

class Zproc {

//    static {
//        Map<String, Boolean> libraries = new LinkedHashMap<>()
//        libraries.put("zmq", false)
//        libraries.put("uuid", true)
//        libraries.put("systemd", true)
//        libraries.put("lz4", true)
//        libraries.put("curl", true)
//        libraries.put("nss", true)
//        libraries.put("microhttpd", true)
//        libraries.put("czmq", false)
//        libraries.put("czmqjni", false)
//        ZmqNativeLoader.loadLibraries(libraries)
//    }

    private interface NativeLib : Library {
        fun zproc_new(): Pointer
        fun destroy(self: Pointer)
        fun zproc_args(self: Pointer): Pointer
        fun zproc_set_args(self: Pointer, arguments: Pointer): Unit
        fun zproc_set_argsx(self: Pointer, arguments: Array<out String>): Unit
        fun zproc_set_env(self: Pointer, arguments: Pointer): Unit
        fun zproc_set_stdin(self: Pointer, socket: Pointer): Unit
        fun zproc_set_stdout(self: Pointer, socket: Pointer): Unit
        fun zproc_set_stderr(self: Pointer, socket: Pointer): Unit
        fun zproc_stdin(self: Pointer): Pointer
        fun zproc_stdout(self: Pointer): Pointer
        fun zproc_stderr(self: Pointer): Pointer
        fun zproc_run(self: Pointer): Int
        fun zproc_returncode(self: Pointer): Int
        fun zproc_pid(self: Pointer): Int
        fun zproc_running(self: Pointer): Boolean
        fun zproc_wait(self: Pointer, timeout: Int): Int
        fun zproc_shutdown(self: Pointer, timeout: Int): Unit
        fun zproc_actor(self: Pointer): Pointer
        fun zproc_kill(self: Pointer, signal: Int): Unit
        fun zproc_set_verbose(self: Pointer, verbose: Boolean): Unit
        fun zproc_test(verbose: Boolean): Unit
    }

    companion object {
        private val nativeLib: NativeLib =
            Native.load("czmq", NativeLib::class.java)

    /**
     * Self test of this class.
     */
    fun test(verbose: Boolean): Unit {
        nativeLib.zproc_test(verbose)
    }

    }

    var self: Pointer

    /**
     * Create a new zproc.
     * NOTE: On Windows and with libzmq3 and libzmq2 this function
     * returns NULL. Code needs to be ported there.
     */
    constructor() {
        /*  TODO: if __new fails, self is null...            */
        self = nativeLib.zproc_new()
    }

    constructor(pointer: Pointer) {
        self = pointer
    }

    /**
     * Destroy zproc, wait until process ends.
     */
//    @Override
//    public void close () {
//        nativeLib.zproc_destroy(self)
//        self = 0
//    }
//
    /**
     * Return command line arguments (the first item is the executable) or
     * NULL if not set.
     */
    fun args(): Zlist {
        return Zlist (nativeLib.zproc_args(self))
    }

    /**
     * Setup the command line arguments, the first item must be an (absolute) filename
     * to run.
     */
    fun setArgs(arguments: Zlist): Unit {
        nativeLib.zproc_set_args(self, arguments.self)
    }

    /**
     * Setup the command line arguments, the first item must be an (absolute) filename
     * to run. Variadic function, must be NULL terminated.
     */
    fun setArgsx(vararg arguments: String): Unit {
        nativeLib.zproc_set_argsx(self, arguments)
    }

    /**
     * Setup the environment variables for the process.
     */
    fun setEnv(arguments: Zhash): Unit {
        nativeLib.zproc_set_env(self, arguments.self)
    }

    /**
     * Connects process stdin with a readable ('>', connect) zeromq socket. If
     * socket argument is NULL, zproc creates own managed pair of inproc
     * sockets.  The writable one is then accessible via zproc_stdin method.
     */
    fun setStdin(socket: Pointer): Unit {
        nativeLib.zproc_set_stdin(self, socket)
    }

    /**
     * Connects process stdout with a writable ('@', bind) zeromq socket. If
     * socket argument is NULL, zproc creates own managed pair of inproc
     * sockets.  The readable one is then accessible via zproc_stdout method.
     */
    fun setStdout(socket: Pointer): Unit {
        nativeLib.zproc_set_stdout(self, socket)
    }

    /**
     * Connects process stderr with a writable ('@', bind) zeromq socket. If
     * socket argument is NULL, zproc creates own managed pair of inproc
     * sockets.  The readable one is then accessible via zproc_stderr method.
     */
    fun setStderr(socket: Pointer): Unit {
        nativeLib.zproc_set_stderr(self, socket)
    }

    /**
     * Return subprocess stdin writable socket. NULL for
     * not initialized or external sockets.
     */
    fun stdin(): Pointer {
        return nativeLib.zproc_stdin(self)
    }

    /**
     * Return subprocess stdout readable socket. NULL for
     * not initialized or external sockets.
     */
    fun stdout(): Pointer {
        return nativeLib.zproc_stdout(self)
    }

    /**
     * Return subprocess stderr readable socket. NULL for
     * not initialized or external sockets.
     */
    fun stderr(): Pointer {
        return nativeLib.zproc_stderr(self)
    }

    /**
     * Starts the process, return just before execve/CreateProcess.
     */
    fun run(): Int {
        return nativeLib.zproc_run(self)
    }

    /**
     * process exit code
     */
    fun returncode(): Int {
        return nativeLib.zproc_returncode(self)
    }

    /**
     * PID of the process
     */
    fun pid(): Int {
        return nativeLib.zproc_pid(self)
    }

    /**
     * return true if process is running, false if not yet started or finished
     */
    fun running(): Boolean {
        return nativeLib.zproc_running(self)
    }

    /**
     * The timeout should be zero or greater, or -1 to wait indefinitely.
     * wait or poll process status, return return code
     */
    fun `wait`(timeout: Int): Int {
        return nativeLib.zproc_wait(self, timeout)
    }

    /**
     * send SIGTERM signal to the subprocess, wait for grace period and
     * eventually send SIGKILL
     */
    fun shutdown(timeout: Int): Unit {
        nativeLib.zproc_shutdown(self, timeout)
    }

    /**
     * return internal actor, useful for the polling if process died
     */
    fun actor(): Pointer {
        return nativeLib.zproc_actor(self)
    }

    /**
     * send a signal to the subprocess
     */
    fun kill(signal: Int): Unit {
        nativeLib.zproc_kill(self, signal)
    }

    /**
     * set verbose mode
     */
    fun setVerbose(verbose: Boolean): Unit {
        nativeLib.zproc_set_verbose(self, verbose)
    }

}
