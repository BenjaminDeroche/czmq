/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer

class Zfile {

//    static {
//        Map<String, Boolean> libraries = new LinkedHashMap<>()
//        libraries.put("zmq", false)
//        libraries.put("uuid", true)
//        libraries.put("systemd", true)
//        libraries.put("lz4", true)
//        libraries.put("curl", true)
//        libraries.put("nss", true)
//        libraries.put("microhttpd", true)
//        libraries.put("czmq", false)
//        libraries.put("czmqjni", false)
//        ZmqNativeLoader.loadLibraries(libraries)
//    }

    private interface NativeLib : Library {
        fun zfile_new(path: String, name: String): Pointer
        fun zfile_tmp(): Pointer
        fun destroy(self: Pointer)
        fun zfile_dup(self: Pointer): Pointer
        fun zfile_filename(self: Pointer, path: String): String
        fun zfile_restat(self: Pointer): Unit
        fun zfile_modified(self: Pointer): Pointer
        fun zfile_cursize(self: Pointer): Pointer
        fun zfile_is_directory(self: Pointer): Boolean
        fun zfile_is_regular(self: Pointer): Boolean
        fun zfile_is_readable(self: Pointer): Boolean
        fun zfile_is_writeable(self: Pointer): Boolean
        fun zfile_is_stable(self: Pointer): Boolean
        fun zfile_has_changed(self: Pointer): Boolean
        fun zfile_remove(self: Pointer): Unit
        fun zfile_input(self: Pointer): Int
        fun zfile_output(self: Pointer): Int
        fun zfile_read(self: Pointer, bytes: Pointer, offset: Pointer): Pointer
        fun zfile_eof(self: Pointer): Boolean
        fun zfile_write(self: Pointer, chunk: Pointer, offset: Pointer): Int
        fun zfile_readln(self: Pointer): String
        fun zfile_close(self: Pointer): Unit
        fun zfile_digest(self: Pointer): String
        fun zfile_test(verbose: Boolean): Unit
    }

    companion object {
        private val nativeLib: NativeLib =
            Native.load("czmq", NativeLib::class.java)

    /**
     * Self test of this class.
     */
    fun test(verbose: Boolean): Unit {
        nativeLib.zfile_test(verbose)
    }

    }

    var self: Pointer

    /**
     * If file exists, populates properties. CZMQ supports portable symbolic
     * links, which are files with the extension ".ln". A symbolic link is a
     * text file containing one line, the filename of a target file. Reading
     * data from the symbolic link actually reads from the target file. Path
     * may be NULL, in which case it is not used.
     */
    constructor(path: String, name: String) {
        /*  TODO: if __new fails, self is null...            */
        self = nativeLib.zfile_new(path, name)
    }

    constructor(pointer: Pointer) {
        self = pointer
    }

    /**
     * Create new temporary file for writing via tmpfile. File is automatically
     * deleted on destroy
     */
//    public static Zfile tmp () {
//        return new Zfile (nativeLib.zfile_tmp ())
//    }
//
    /**
     * Destroy a file item
     */
//    @Override
//    public void close () {
//        nativeLib.zfile_destroy(self)
//        self = 0
//    }
//
    /**
     * Duplicate a file item, returns a newly constructed item. If the file
     * is null, or memory was exhausted, returns null.
     */
    fun dup(): Zfile {
        return Zfile (nativeLib.zfile_dup(self))
    }

    /**
     * Return file name, remove path if provided
     */
    fun filename(path: String): String {
        return nativeLib.zfile_filename(self, path)
    }

    /**
     * Refresh file properties from disk; this is not done automatically
     * on access methods, otherwise it is not possible to compare directory
     * snapshots.
     */
    fun restat(): Unit {
        nativeLib.zfile_restat(self)
    }

    /**
     * Return when the file was last modified. If you want this to reflect the
     * current situation, call zfile_restat before checking this property.
     */
    fun modified(): Pointer {
        return nativeLib.zfile_modified(self)
    }

    /**
     * Return the last-known size of the file. If you want this to reflect the
     * current situation, call zfile_restat before checking this property.
     */
    fun cursize(): Pointer {
        return nativeLib.zfile_cursize(self)
    }

    /**
     * Return true if the file is a directory. If you want this to reflect
     * any external changes, call zfile_restat before checking this property.
     */
    fun isDirectory(): Boolean {
        return nativeLib.zfile_is_directory(self)
    }

    /**
     * Return true if the file is a regular file. If you want this to reflect
     * any external changes, call zfile_restat before checking this property.
     */
    fun isRegular(): Boolean {
        return nativeLib.zfile_is_regular(self)
    }

    /**
     * Return true if the file is readable by this process. If you want this to
     * reflect any external changes, call zfile_restat before checking this
     * property.
     */
    fun isReadable(): Boolean {
        return nativeLib.zfile_is_readable(self)
    }

    /**
     * Return true if the file is writeable by this process. If you want this
     * to reflect any external changes, call zfile_restat before checking this
     * property.
     */
    fun isWriteable(): Boolean {
        return nativeLib.zfile_is_writeable(self)
    }

    /**
     * Check if file has stopped changing and can be safely processed.
     * Updates the file statistics from disk at every call.
     */
    fun isStable(): Boolean {
        return nativeLib.zfile_is_stable(self)
    }

    /**
     * Return true if the file was changed on disk since the zfile_t object
     * was created, or the last zfile_restat() call made on it.
     */
    fun hasChanged(): Boolean {
        return nativeLib.zfile_has_changed(self)
    }

    /**
     * Remove the file from disk
     */
    fun remove(): Unit {
        nativeLib.zfile_remove(self)
    }

    /**
     * Open file for reading
     * Returns 0 if OK, -1 if not found or not accessible
     */
    fun input(): Int {
        return nativeLib.zfile_input(self)
    }

    /**
     * Open file for writing, creating directory if needed
     * File is created if necessary; chunks can be written to file at any
     * location. Returns 0 if OK, -1 if error.
     */
    fun output(): Int {
        return nativeLib.zfile_output(self)
    }

    /**
     * Read chunk from file at specified position. If this was the last chunk,
     * sets the eof property. Returns a null chunk in case of error.
     */
    fun read(bytes: Pointer, offset: Pointer): Zchunk {
        return Zchunk (nativeLib.zfile_read(self, bytes, offset))
    }

    /**
     * Returns true if zfile_read() just read the last chunk in the file.
     */
    fun eof(): Boolean {
        return nativeLib.zfile_eof(self)
    }

    /**
     * Write chunk to file at specified position
     * Return 0 if OK, else -1
     */
    fun write(chunk: Zchunk, offset: Pointer): Int {
        return nativeLib.zfile_write(self, chunk.self, offset)
    }

    /**
     * Read next line of text from file. Returns a pointer to the text line,
     * or NULL if there was nothing more to read from the file.
     */
    fun readln(): String {
        return nativeLib.zfile_readln(self)
    }

    /**
     * Close file, if open
     */
    fun `close`(): Unit {
        nativeLib.zfile_close(self)
    }

    /**
     * Calculate SHA1 digest for file, using zdigest class.
     */
    fun digest(): String {
        return nativeLib.zfile_digest(self)
    }

}
