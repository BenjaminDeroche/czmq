/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer

class Zchunk {

//    static {
//        Map<String, Boolean> libraries = new LinkedHashMap<>()
//        libraries.put("zmq", false)
//        libraries.put("uuid", true)
//        libraries.put("systemd", true)
//        libraries.put("lz4", true)
//        libraries.put("curl", true)
//        libraries.put("nss", true)
//        libraries.put("microhttpd", true)
//        libraries.put("czmq", false)
//        libraries.put("czmqjni", false)
//        ZmqNativeLoader.loadLibraries(libraries)
//    }

    private interface NativeLib : Library {
        fun zchunk_new(data: ByteArray, size: Pointer): Pointer
        fun destroy(self: Pointer)
        fun zchunk_resize(self: Pointer, size: Pointer): Unit
        fun zchunk_size(self: Pointer): Pointer
        fun zchunk_max_size(self: Pointer): Pointer
        fun zchunk_data(self: Pointer): ByteArray
        fun zchunk_set(self: Pointer, data: ByteArray, size: Pointer): Pointer
        fun zchunk_fill(self: Pointer, filler: Byte, size: Pointer): Pointer
        fun zchunk_append(self: Pointer, data: ByteArray, size: Pointer): Pointer
        fun zchunk_extend(self: Pointer, data: ByteArray, size: Pointer): Pointer
        fun zchunk_consume(self: Pointer, source: Pointer): Pointer
        fun zchunk_exhausted(self: Pointer): Boolean
        fun zchunk_slurp(filename: String, maxsize: Pointer): Pointer
        fun zchunk_dup(self: Pointer): Pointer
        fun zchunk_strhex(self: Pointer): String
        fun zchunk_strdup(self: Pointer): String
        fun zchunk_streq(self: Pointer, string: String): Boolean
        fun zchunk_pack(self: Pointer): Pointer
        fun zchunk_packx(self: Pointer): Pointer
        fun zchunk_unpack(frame: Pointer): Pointer
        fun zchunk_digest(self: Pointer): String
        fun zchunk_print(self: Pointer): Unit
        fun zchunk_is(self: Pointer): Boolean
        fun zchunk_test(verbose: Boolean): Unit
    }

    companion object {
        private val nativeLib: NativeLib =
            Native.load("czmq", NativeLib::class.java)

    /**
     * Try to slurp an entire file into a chunk. Will read up to maxsize of
     * the file. If maxsize is 0, will attempt to read the entire file and
     * fail with an assertion if that cannot fit into memory. Returns a new
     * chunk containing the file data, or NULL if the file could not be read.
     */
    fun slurp(filename: String, maxsize: Pointer): Zchunk {
        return Zchunk (nativeLib.zchunk_slurp(filename, maxsize))
    }

    /**
     * Transform a zframe into a zchunk.
     */
    fun unpack(frame: Zframe): Zchunk {
        return Zchunk (nativeLib.zchunk_unpack(frame.self))
    }

    /**
     * Probe the supplied object, and report if it looks like a zchunk_t.
     */
    fun `is`(self: Pointer): Boolean {
        return nativeLib.zchunk_is(self)
    }

    /**
     * Self test of this class.
     */
    fun test(verbose: Boolean): Unit {
        nativeLib.zchunk_test(verbose)
    }

    }

    var self: Pointer

    /**
     * Create a new chunk of the specified size. If you specify the data, it
     * is copied into the chunk. If you do not specify the data, the chunk is
     * allocated and left empty, and you can then add data using zchunk_append.
     */
    constructor(data: ByteArray, size: Pointer) {
        /*  TODO: if __new fails, self is null...            */
        self = nativeLib.zchunk_new(data, size)
    }

    constructor(pointer: Pointer) {
        self = pointer
    }

    /**
     * Destroy a chunk
     */
//    @Override
//    public void close () {
//        nativeLib.zchunk_destroy(self)
//        self = 0
//    }
//
    /**
     * Resizes chunk max_size as requested; chunk_cur size is set to zero
     */
    fun resize(size: Pointer): Unit {
        nativeLib.zchunk_resize(self, size)
    }

    /**
     * Return chunk cur size
     */
    fun size(): Pointer {
        return nativeLib.zchunk_size(self)
    }

    /**
     * Return chunk max size
     */
    fun maxSize(): Pointer {
        return nativeLib.zchunk_max_size(self)
    }

    /**
     * Return chunk data
     */
    fun data(): ByteArray {
        return nativeLib.zchunk_data(self)
    }

    /**
     * Set chunk data from user-supplied data; truncate if too large. Data may
     * be null. Returns actual size of chunk
     */
    fun set(data: ByteArray, size: Pointer): Pointer {
        return nativeLib.zchunk_set(self, data, size)
    }

    /**
     * Fill chunk data from user-supplied octet
     */
    fun fill(filler: Byte, size: Pointer): Pointer {
        return nativeLib.zchunk_fill(self, filler, size)
    }

    /**
     * Append user-supplied data to chunk, return resulting chunk size. If the
     * data would exceeded the available space, it is truncated. If you want to
     * grow the chunk to accommodate new data, use the zchunk_extend method.
     */
    fun append(data: ByteArray, size: Pointer): Pointer {
        return nativeLib.zchunk_append(self, data, size)
    }

    /**
     * Append user-supplied data to chunk, return resulting chunk size. If the
     * data would exceeded the available space, the chunk grows in size.
     */
    fun extend(data: ByteArray, size: Pointer): Pointer {
        return nativeLib.zchunk_extend(self, data, size)
    }

    /**
     * Copy as much data from 'source' into the chunk as possible; returns the
     * new size of chunk. If all data from 'source' is used, returns exhausted
     * on the source chunk. Source can be consumed as many times as needed until
     * it is exhausted. If source was already exhausted, does not change chunk.
     */
    fun consume(source: Zchunk): Pointer {
        return nativeLib.zchunk_consume(self, source.self)
    }

    /**
     * Returns true if the chunk was exhausted by consume methods, or if the
     * chunk has a size of zero.
     */
    fun exhausted(): Boolean {
        return nativeLib.zchunk_exhausted(self)
    }

    /**
     * Create copy of chunk, as new chunk object. Returns a fresh zchunk_t
     * object, or null if there was not enough heap memory. If chunk is null,
     * returns null.
     */
    fun dup(): Zchunk {
        return Zchunk (nativeLib.zchunk_dup(self))
    }

    /**
     * Return chunk data encoded as printable hex string. Caller must free
     * string when finished with it.
     */
    fun strhex(): String {
        return nativeLib.zchunk_strhex(self)
    }

    /**
     * Return chunk data copied into freshly allocated string
     * Caller must free string when finished with it.
     */
    fun strdup(): String {
        return nativeLib.zchunk_strdup(self)
    }

    /**
     * Return TRUE if chunk body is equal to string, excluding terminator
     */
    fun streq(string: String): Boolean {
        return nativeLib.zchunk_streq(self, string)
    }

    /**
     * Transform zchunk into a zframe that can be sent in a message.
     */
    fun pack(): Zframe {
        return Zframe (nativeLib.zchunk_pack(self))
    }

    /**
     * Transform zchunk into a zframe that can be sent in a message.
     * Take ownership of the chunk.
     */
    fun packx(): Unit {
        self = nativeLib.zchunk_packx(self)
    }

    /**
     * Calculate SHA1 digest for chunk, using zdigest class.
     */
    fun digest(): String {
        return nativeLib.zchunk_digest(self)
    }

    /**
     * Dump message to stderr, for debugging and tracing.
     * See zchunk_fprint for details
     */
    fun print(): Unit {
        nativeLib.zchunk_print(self)
    }

}
